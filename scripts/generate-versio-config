#!/usr/bin/env zx

const toml = require('@iarna/toml');

$.verbose = false

const {stdout: workspaceRaw} = await $`cat ./Cargo.toml`

let workspace = toml.parse(workspaceRaw).workspace;


let packages = [];

// Find all packages
for (let memberPath of workspace.members) {
  const {stdout: memberCargoTomlRaw} = await $`cat ${memberPath}/Cargo.toml`;
  let memberCargoToml = toml.parse(memberCargoTomlRaw);
  let name = memberCargoToml.package.name;
  let deps = Object.entries(memberCargoToml.dependencies)
    .filter(([_, dep]) => dep?.path)
  // Only packages in libs directory
    .filter(([_, { path }]) => path.split('/')[0] == '..')
    .map(([name]) => name);

  packages.push({ name, path: memberPath, deps });
}

// Resolve implicit dependencies
const getPackageDeps = (packageName) => {
  const packagesMap = new Map(packages.map(p => [p.name, p]));
  let visited = new Set();

  const getPackageDepsInner = (packageName, visited = new Set()) => {
    if (visited.has(packageName)) return;
    visited.add(packageName);
    const found = packagesMap.get(packageName);
    if (!found) return;

    for (let dep of found.deps) {
      getPackageDepsInner(dep, visited);
    }
  }

  getPackageDepsInner(packageName, visited);

  visited.delete(packageName);

  return Array.from(visited);
}


for (let p of packages) {
  p.deps = getPackageDeps(p.name);
}


// Generate unique id for each package (versio requirement)
function uniqueIdFromPackageName(packageName) {
    let hash = 0;
    for (let i = 0; i < packageName.length; i++) {
        const char = packageName.charCodeAt(i);
        // Combine the current hash with the current character code,
        // then ensure it remains within 32-bit integer range by using bitwise OR.
        // This is a simplification to work within JavaScript's limitations.
        hash = (hash * 31 + char) | 0;
    }
    // Return the hash as a simulated 64-bit number. In JavaScript, this will still be a Number,
    // but we're treating it as if it's a 64-bit integer for the sake of this function.
    return hash >>> 0; // Convert to unsigned 32-bit integer
}

for (let p of packages) {
  // This function can generate conflicting id in extreme rare cases.
  p.id = uniqueIdFromPackageName(p.name);
}


// Generate versio config
const idOf = (name) => packages.find((p) => p.name ==name).id;

let projects = packages.flatMap(({ name, path, deps, id }) =>
`  - name: "${name}"
    id: ${id}
    labels: cargo
    changelog: "CHANGELOG.html"
    root: "${path}"
    version:
      file: "Cargo.toml"
      toml: "package.version"
    hooks:
      post_write: cargo update --workspace
${deps.length >= 1 ? '    depends:' : ''}
${deps.map((dep) => `      ${idOf(dep)}:
        size: patch
        files:
          - file: "Cargo.toml"
            toml: "package.version"
`).join('\n') ?? ''}
`.split('\n')).filter(Boolean).join('\n');

const wholeFile = `# This file was autogenerated!!
# modify .versio-projects.json instead and re-run the command 'just update-versio-config'

options:
  prev_tag: "prev"

projects:
${projects}

sizes:
  major: [ "!" ]
  minor: [ feat, revert ]
  patch: [ fix, build, refactor, style ]
  none: [ release, chore, infra, docs, test ]
  fail: ["*"]

commit:
  message: "release: updating packages version"
  author: "Versio"
  email: "github.com/chaaz/versio"
`

await $`echo ${wholeFile} > .versio.yaml`
